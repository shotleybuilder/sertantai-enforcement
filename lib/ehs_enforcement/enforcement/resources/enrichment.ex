defmodule EhsEnforcement.Enforcement.Enrichment do
  @moduledoc """
  AI-generated enrichment data for enforcement actions (Cases and Notices).

  This resource stores contextual intelligence generated by AI including:
  - Regulation cross-references and legislation analysis
  - Industry benchmark comparisons
  - Historical pattern detection
  - Plain language summaries (layperson and professional)
  - Auto-generated tags and classifications
  - Confidence scores for AI-generated content

  ## Unified Design

  Unlike Cases and Notices (which are separate due to different domain semantics),
  enrichments use a unified table because:
  - Schema is identical for both types
  - AI enrichment logic is the same
  - Follows existing pattern from Offences resource
  - Maintains DRY principle

  ## Relationships

  An enrichment belongs to either a Case OR a Notice (enforced by database constraint).
  This follows the same pattern as the Offences resource.

  ## Example Usage

      # Enrich a case
      {:ok, enrichment} = Ash.create(Enrichment, %{
        case_id: case.id,
        regulation_links: [...],
        benchmark_analysis: %{...},
        layperson_summary: "...",
        model_version: "gpt-4-turbo"
      })

      # Query enrichment by case
      {:ok, enrichment} = Enrichment.by_case!(case_id)

      # Query enrichment by notice
      {:ok, enrichment} = Enrichment.by_notice!(notice_id)
  """

  use Ash.Resource,
    domain: EhsEnforcement.Enforcement,
    data_layer: AshPostgres.DataLayer,
    extensions: [AshEvents.Events],
    notifiers: [Ash.Notifier.PubSub]

  postgres do
    table("enrichments")
    repo(EhsEnforcement.Repo)

    # Database constraint: exactly one parent (case XOR notice)
    check_constraints do
      check_constraint(
        :must_have_one_parent,
        "(case_id IS NOT NULL AND notice_id IS NULL) OR (case_id IS NULL AND notice_id IS NOT NULL)",
        message: "Enrichment must belong to either a case or notice, but not both"
      )
    end

    custom_indexes do
      # Performance indexes for lookup queries
      index([:case_id], name: "enrichments_case_id_index")
      index([:notice_id], name: "enrichments_notice_id_index")

      # Index for querying by model version (useful for A/B testing)
      index([:model_version], name: "enrichments_model_version_index")

      # Composite index for generated_at (time-series analysis)
      index([:generated_at], name: "enrichments_generated_at_index")

      # Partial index for recently generated enrichments
      index([:generated_at],
        name: "enrichments_recent_index",
        where: "generated_at > NOW() - INTERVAL '30 days'"
      )

      # GIN indexes for JSONB fields (enables efficient JSON queries)
      index([:regulation_links], name: "enrichments_regulation_links_gin", using: "GIN")
      index([:benchmark_analysis], name: "enrichments_benchmark_analysis_gin", using: "GIN")
      index([:confidence_scores], name: "enrichments_confidence_scores_gin", using: "GIN")
    end
  end

  pub_sub do
    module(EhsEnforcement.PubSub)
    prefix("enrichment")

    # Broadcast when enrichment is created
    publish(:create, ["created", :id])
    publish(:create, ["created"])

    # Broadcast when enrichment is updated
    publish(:update, ["updated", :id])
    publish(:update, ["updated"])

    # Broadcast when enrichment is destroyed
    publish(:destroy, ["deleted", :id])
  end

  attributes do
    uuid_primary_key(:id)

    # Regulation cross-references
    attribute :regulation_links, {:array, :map} do
      description """
      AI-identified regulation references extracted from breach descriptions.
      Each entry contains: {act, section, relevance_score, summary}
      """
    end

    # Benchmark analysis
    attribute :benchmark_analysis, :map do
      description """
      Industry benchmark comparisons.
      - For Cases: fine amount percentiles, average fines for similar violations
      - For Notices: compliance timelines, notice escalation patterns
      """
    end

    # Pattern detection
    attribute :pattern_detection, :map do
      description """
      Historical pattern analysis including:
      - Similar cases/notices count
      - Trend analysis (increasing/decreasing enforcement)
      - Notable precedents
      - Repeat offender patterns
      """
    end

    # Summaries
    attribute :layperson_summary, :string do
      description "Plain language summary (Grade 8-10 reading level) for non-technical users"
    end

    attribute :professional_summary, :string do
      description "Technical summary for compliance officers and legal professionals"
    end

    # Auto-tags
    attribute :auto_tags, {:array, :string} do
      description "AI-generated categorization tags (e.g., 'construction', 'fatal-accident', 'repeat-offender')"
      default([])
    end

    # Confidence scores
    attribute :confidence_scores, :map do
      description """
      Confidence scores (0.0-1.0) for each AI-generated section:
      {regulation_links: 0.95, benchmark_accuracy: 0.87, pattern_detection: 0.82, ...}
      """
    end

    # Metadata
    attribute :model_version, :string do
      description "AI model version used (e.g., 'gpt-4-turbo', 'claude-sonnet-3.5')"
      allow_nil?(false)
    end

    attribute :generated_at, :utc_datetime_usec do
      description "Timestamp when enrichment was generated"
      default(&DateTime.utc_now/0)
      allow_nil?(false)
    end

    attribute :processing_time_ms, :integer do
      description "Time taken to generate enrichment (milliseconds)"
      constraints(min: 0)
    end

    create_timestamp(:inserted_at)
    update_timestamp(:updated_at)
  end

  relationships do
    belongs_to :case, EhsEnforcement.Enforcement.Case do
      description "Associated enforcement case (court action)"
    end

    belongs_to :notice, EhsEnforcement.Enforcement.Notice do
      description "Associated enforcement notice (compliance order)"
    end

    # Validations from professionals
    has_many :validations, EhsEnforcement.Enforcement.EnrichmentValidation
  end

  events do
    event_log(EhsEnforcement.Events.Event)
    current_action_versions(create: 1, update: 1)
    only_actions([:create, :update])
  end

  actions do
    defaults([:read, :destroy])

    create :create do
      primary?(true)

      accept([
        :regulation_links,
        :benchmark_analysis,
        :pattern_detection,
        :layperson_summary,
        :professional_summary,
        :auto_tags,
        :confidence_scores,
        :model_version,
        :generated_at,
        :processing_time_ms,
        :case_id,
        :notice_id
      ])

      # Validation: exactly one parent required (case XOR notice)
      validate(fn changeset, _context ->
        case_id = Ash.Changeset.get_attribute(changeset, :case_id)
        notice_id = Ash.Changeset.get_attribute(changeset, :notice_id)

        cond do
          case_id && notice_id ->
            {:error,
             field: :base,
             message: "Cannot enrich both case and notice - must choose one parent"}

          case_id || notice_id ->
            :ok

          true ->
            {:error, field: :base, message: "Must provide either case_id or notice_id"}
        end
      end)

      # Validation: model_version is required
      validate(present(:model_version))

      # Validation: at least one enrichment field should be present
      validate(fn changeset, _context ->
        has_content =
          Ash.Changeset.get_attribute(changeset, :regulation_links) != nil or
            Ash.Changeset.get_attribute(changeset, :benchmark_analysis) != nil or
            Ash.Changeset.get_attribute(changeset, :pattern_detection) != nil or
            Ash.Changeset.get_attribute(changeset, :layperson_summary) != nil or
            Ash.Changeset.get_attribute(changeset, :professional_summary) != nil

        if has_content do
          :ok
        else
          {:error,
           field: :base, message: "Enrichment must contain at least one enrichment field"}
        end
      end)
    end

    update :update do
      primary?(true)

      accept([
        :regulation_links,
        :benchmark_analysis,
        :pattern_detection,
        :layperson_summary,
        :professional_summary,
        :auto_tags,
        :confidence_scores
      ])

      # Note: Cannot change case_id/notice_id after creation
      # Note: model_version is immutable (create new enrichment for different model)
    end

    # Query actions
    read :by_case do
      description "Find enrichment for a specific case"
      argument(:case_id, :uuid, allow_nil?: false)
      filter(expr(case_id == ^arg(:case_id)))

      prepare(fn query, _context ->
        # Ensure we get the most recent enrichment if multiple exist
        Ash.Query.sort(query, generated_at: :desc)
        |> Ash.Query.limit(1)
      end)
    end

    read :by_notice do
      description "Find enrichment for a specific notice"
      argument(:notice_id, :uuid, allow_nil?: false)
      filter(expr(notice_id == ^arg(:notice_id)))

      prepare(fn query, _context ->
        # Ensure we get the most recent enrichment if multiple exist
        Ash.Query.sort(query, generated_at: :desc)
        |> Ash.Query.limit(1)
      end)
    end

    read :by_model_version do
      description "Find enrichments generated by a specific AI model version"
      argument(:model_version, :string, allow_nil?: false)
      filter(expr(model_version == ^arg(:model_version)))

      prepare(fn query, _context ->
        Ash.Query.sort(query, generated_at: :desc)
      end)
    end

    read :recent do
      description "Get recently generated enrichments (last 30 days)"

      filter(expr(generated_at > ago(30, :day)))

      prepare(fn query, _context ->
        Ash.Query.sort(query, generated_at: :desc)
      end)
    end

    read :high_confidence do
      description "Get enrichments with high confidence scores (all sections > 0.8)"

      # Note: This uses a simplified filter - actual implementation would need
      # custom SQL to query JSONB fields
      prepare(fn query, _context ->
        Ash.Query.sort(query, generated_at: :desc)
      end)
    end
  end

  calculations do
    calculate :enrichment_type, :atom do
      description "Helper to determine if this enrichment is for a case or notice"

      calculation(
        expr(
          if not is_nil(case_id) do
            :case
          else
            :notice
          end
        )
      )
    end

    calculate :parent_id, :uuid do
      description "Get the ID of the parent (case_id or notice_id)"

      calculation(
        expr(
          if not is_nil(case_id) do
            case_id
          else
            notice_id
          end
        )
      )
    end

    calculate :average_confidence, :float do
      description "Calculate average confidence score across all sections"

      # Note: This would need custom implementation to properly parse JSONB
      # For now, returning a placeholder
      calculation(expr(0.0))
    end
  end

  code_interface do
    define(:create)
    define(:update)
    define(:by_case, args: [:case_id])
    define(:by_notice, args: [:notice_id])
    define(:by_model_version, args: [:model_version])
    define(:recent)
    define(:high_confidence)
  end
end
