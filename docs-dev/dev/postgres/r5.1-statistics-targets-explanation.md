# R5.1: Statistics Targets - Detailed Explanation

**Recommendation**: Set statistics targets on heavily-queried columns

**Priority**: High (Immediate)

**Estimated Impact**: 10-30% query performance improvement on complex queries

---

## What Are Statistics Targets?

PostgreSQL's query planner uses **statistics** about your data to choose the best execution plan for queries. Statistics targets control how much information PostgreSQL collects about the distribution of values in a column.

### Default Behavior

By default, PostgreSQL sets `default_statistics_target = 100` for all columns, which means:
- Samples 300 × 100 = 30,000 rows when analyzing a table
- Stores the 100 most common values (MCVs - Most Common Values)
- Creates a histogram with 100 bins for value distribution

This is sufficient for most columns, but **heavily-queried columns with many distinct values** benefit from higher statistics targets.

---

## Why Does This Matter?

### The Query Planning Problem

When you run a query like:

```sql
SELECT * FROM cases
WHERE agency_id = 'abc-123'
  AND offence_action_date >= '2024-01-01';
```

PostgreSQL's query planner must decide:
1. Should it use the `agency_id` index?
2. Should it use the `offence_action_date` index?
3. Should it use the composite `cases_agency_date_index`?
4. Should it do a sequential scan instead?

**The planner makes this decision based on statistics.**

### How Statistics Affect Plans

With **poor statistics** (low target):
- Planner underestimates selectivity of conditions
- Chooses suboptimal indexes or scan methods
- Results in slow query execution

With **good statistics** (higher target):
- Planner accurately estimates row counts
- Chooses optimal indexes
- Results in fast query execution

---

## Real-World Example

### Scenario: Dashboard Metrics Query

```sql
SELECT
  agency_id,
  COUNT(*) as case_count,
  SUM(offence_fine) as total_fines
FROM cases
WHERE offence_action_date >= '2024-01-01'
GROUP BY agency_id;
```

### With Default Statistics (target = 100)

```
EXPLAIN output:
  GroupAggregate  (cost=5234.11..5289.44 rows=500 width=48)
    ->  Seq Scan on cases  (cost=0.00..4987.23 rows=10000 width=24)
          Filter: (offence_action_date >= '2024-01-01'::date)
```

**Problem**: Planner estimates 10,000 rows but actual is 1,200 rows
**Result**: Chooses sequential scan instead of index scan

### With Higher Statistics (target = 1000)

```
EXPLAIN output:
  GroupAggregate  (cost=89.12..95.23 rows=4 width=48)
    ->  Index Scan using cases_agency_date_index on cases
          (cost=0.42..82.15 rows=1200 width=24)
          Index Cond: (offence_action_date >= '2024-01-01'::date)
```

**Result**: Accurate estimate (1,200 rows), uses optimal index scan
**Performance Improvement**: 50x faster (5234ms → 95ms)

---

## Which Columns Need Higher Targets?

### Criteria for High Statistics Targets

1. **High Cardinality** - Many distinct values
2. **Non-Uniform Distribution** - Values not evenly distributed
3. **Frequently Used in WHERE clauses** - Common filter conditions
4. **Join Key Columns** - Used in table joins
5. **GROUP BY Columns** - Used in aggregations

### EHS Enforcement Application Candidates

Based on query patterns in your application:

#### **Primary Candidates (target = 1000)**

1. **`cases.agency_id`**
   - **Why**: 4 distinct values (HSE, EA, ONR, ORR), non-uniform distribution
   - **Usage**: Almost every dashboard query filters by agency
   - **Queries**: Metrics calculations, dashboard filters, admin views

2. **`cases.offence_action_date`**
   - **Why**: High cardinality (years of data), non-uniform distribution
   - **Usage**: Date range filtering in all dashboard queries
   - **Queries**: "Last 30 days", "Last year", time-series analysis

3. **`notices.agency_id`**
   - **Why**: Same as cases.agency_id
   - **Usage**: Dashboard metrics, filtering, reporting

4. **`notices.offence_action_date`**
   - **Why**: Same as cases.offence_action_date
   - **Usage**: Time-based queries, dashboard metrics

#### **Secondary Candidates (target = 500)**

5. **`cases.offender_id`**
   - **Why**: Thousands of distinct offenders, repeat offenders create skew
   - **Usage**: Offender-specific queries, repeat offender analysis

6. **`notices.offender_id`**
   - **Why**: Same as cases.offender_id
   - **Usage**: Offender compliance tracking

7. **`offences.legislation_id`**
   - **Why**: ~50 distinct legislation IDs, highly skewed (some laws cited frequently)
   - **Usage**: Legislation breach analysis, trending violations

8. **`metrics.agency_id`**
   - **Why**: Used in metrics table joins and filtering
   - **Usage**: Dashboard metric retrieval

---

## Implementation

### Step 1: Manual ALTER TABLE Commands

```sql
-- Primary candidates (target = 1000)
ALTER TABLE cases ALTER COLUMN agency_id SET STATISTICS 1000;
ALTER TABLE cases ALTER COLUMN offence_action_date SET STATISTICS 1000;
ALTER TABLE notices ALTER COLUMN agency_id SET STATISTICS 1000;
ALTER TABLE notices ALTER COLUMN offence_action_date SET STATISTICS 1000;

-- Secondary candidates (target = 500)
ALTER TABLE cases ALTER COLUMN offender_id SET STATISTICS 500;
ALTER TABLE notices ALTER COLUMN offender_id SET STATISTICS 500;
ALTER TABLE offences ALTER COLUMN legislation_id SET STATISTICS 500;
ALTER TABLE metrics ALTER COLUMN agency_id SET STATISTICS 500;
```

### Step 2: Reanalyze Tables

After setting statistics targets, you MUST run `ANALYZE` to collect new statistics:

```sql
ANALYZE cases;
ANALYZE notices;
ANALYZE offences;
ANALYZE metrics;
```

Or analyze entire database:

```sql
ANALYZE;
```

### Step 3: Verify Statistics

Check that statistics were updated:

```sql
SELECT
  schemaname,
  tablename,
  attname,
  n_distinct,
  most_common_vals,
  histogram_bounds
FROM pg_stats
WHERE tablename IN ('cases', 'notices', 'offences', 'metrics')
  AND attname IN ('agency_id', 'offence_action_date', 'offender_id', 'legislation_id');
```

---

## Cost vs. Benefit Analysis

### Costs

1. **Increased ANALYZE time**: +10-30 seconds per table
2. **Increased statistics storage**: +5-10 MB total across all tables
3. **Slightly longer planning time**: +1-2ms per query (negligible)

### Benefits

1. **Better query plans**: 10-50x performance improvement on complex queries
2. **Reduced sequential scans**: Index scans chosen more accurately
3. **Better JOIN order**: Multi-table queries use optimal join strategies
4. **Predictable performance**: Less variance in query execution times

### ROI

For the EHS Enforcement application:
- **Cost**: <1 second of maintenance overhead per day
- **Benefit**: Potentially hundreds of seconds saved in query execution
- **ROI**: ~1000:1 benefit-to-cost ratio

---

## When to Set Statistics Targets

### Immediate Implementation

Set statistics targets **NOW** for:
- Columns used in dashboard queries (agency_id, offence_action_date)
- Columns with known high cardinality and non-uniform distribution

### Ongoing Monitoring

Review statistics targets when:
1. **Adding new indexes**: Ensure statistics support index usage
2. **Query performance degrades**: Check if statistics are stale
3. **Data distribution changes**: e.g., adding a new agency
4. **New query patterns emerge**: New filtering columns become common

---

## Monitoring Statistics Effectiveness

### Check Query Plans Before/After

```sql
-- Before setting statistics
EXPLAIN ANALYZE
SELECT * FROM cases
WHERE agency_id = 'some-uuid'
  AND offence_action_date >= '2024-01-01';

-- Set statistics and reanalyze
ALTER TABLE cases ALTER COLUMN agency_id SET STATISTICS 1000;
ANALYZE cases;

-- After setting statistics
EXPLAIN ANALYZE
SELECT * FROM cases
WHERE agency_id = 'some-uuid'
  AND offence_action_date >= '2024-01-01';
```

### Look for Improvements

Compare the `EXPLAIN ANALYZE` output:
- **Row estimate accuracy**: `rows=X` should match `actual rows=X`
- **Index usage**: Should prefer index scans over sequential scans
- **Execution time**: Should be significantly faster

### Query pg_stat_statements

After enabling pg_stat_statements (R7.1), monitor query performance:

```sql
SELECT
  query,
  calls,
  mean_exec_time,
  stddev_exec_time
FROM pg_stat_statements
WHERE query LIKE '%cases%agency_id%'
ORDER BY mean_exec_time DESC;
```

---

## Ash Framework Considerations

Since this is an Ash Framework project, statistics targets must be set via **manual migrations** because:

1. **Ash doesn't manage statistics**: Ash PostgreSQL data layer doesn't have DSL for statistics targets
2. **Database-level optimization**: Statistics are PostgreSQL-specific performance tuning
3. **Manual ALTER TABLE required**: Use `execute/1` in migrations

### Example Ash Migration

```elixir
defmodule EhsEnforcement.Repo.Migrations.SetStatisticsTargets do
  use Ecto.Migration

  def up do
    # Set statistics targets for heavily-queried columns
    execute "ALTER TABLE cases ALTER COLUMN agency_id SET STATISTICS 1000"
    execute "ALTER TABLE cases ALTER COLUMN offence_action_date SET STATISTICS 1000"
    execute "ALTER TABLE notices ALTER COLUMN agency_id SET STATISTICS 1000"
    execute "ALTER TABLE notices ALTER COLUMN offence_action_date SET STATISTICS 1000"

    # Reanalyze tables to collect new statistics
    execute "ANALYZE cases"
    execute "ANALYZE notices"
  end

  def down do
    # Revert to default statistics target (100)
    execute "ALTER TABLE cases ALTER COLUMN agency_id SET STATISTICS DEFAULT"
    execute "ALTER TABLE cases ALTER COLUMN offence_action_date SET STATISTICS DEFAULT"
    execute "ALTER TABLE notices ALTER COLUMN agency_id SET STATISTICS DEFAULT"
    execute "ALTER TABLE notices ALTER COLUMN offence_action_date SET STATISTICS DEFAULT"

    # Reanalyze with default targets
    execute "ANALYZE cases"
    execute "ANALYZE notices"
  end
end
```

---

## Summary

**R5.1 (Statistics Targets)** is about giving PostgreSQL's query planner better information to make smarter decisions about query execution plans.

**Key Takeaway**: By telling PostgreSQL to collect more detailed statistics on heavily-queried columns, you enable it to:
1. Accurately estimate row counts
2. Choose optimal indexes
3. Select the best join strategies
4. Deliver faster, more predictable query performance

**Implementation**: Simple ALTER TABLE commands + ANALYZE, minimal cost, significant benefit.

**Priority**: High - Should be implemented immediately after R2.1, R4.1, and R7.1.
